;; Implement a basic Forth interpreter using stage3

;; Set up labels for variables and segments:
00200000@ :glbl  ; global variables
00200004@ :FDIN  ; file descriptor for input
00200008@ :FDOT  ; file descriptor for output
0020000C@ :FTXT  ; pointer to free text space
00200010@ :FSTR  ; pointer to free string space
00200014@ :HEAD  ; pointer to the latest defined word
00200018@ :OESP  ; original esp 


00200020@ :temp  ; temporary variable for internal use
00300000@ :fstk  ; forth stack
00100000@ :fstz  ; forth stack size
00500000@ :strb  ; string buffer

;; text segment starts at virtual address 00010000
00010000@ :text

;; ELF header:
7F "ELF" 01 01 01 00
00 00 00 00 00 00 00 00

0002     ; type
0003     ; machine
00000000 ; version
=main    ; entry
$PH      ; phoff (00000034)
00000000 ; shoff
00000000 ; flags
0034     ; ehsize
0020     ; phentsize
0004     ; phnum (4)
0000     ; shentsize
0000     ; shnum
0000     ; shstrndx

:PH
;; Program header 1: the program text.
;; It also contains the words to be loaded later.
00000001 ; type
00000000 ; offset
=text    ; vaddr
00000000 ; paddr
$EOF     ; filesz
00100000 ; memsz 1 MiB
00000007 ; flags
00001000 ; alignment

;; Program header 2: global variables, 4 KiB
00000001 ; type
00000000 ; offset
=glbl    ; vaddr
00000000 ; paddr
00000000 ; filesz
00001000 ; memsz 4 KiB
00000006 ; flags (no execute)
00001000 ; alignment

;; Program header 3: forth stack, 1 MiB
;; from 0x00300000 to 0x00400000
;; the stack pointer is edi, pointed to 0x00400000 initialialy
00000001 ; type
00000000 ; offset
=fstk    ; vaddr
00000000 ; paddr
00000000 ; filesz
00100000 ; memsz 1 MiB
00000006 ; flags (no execute)
00001000 ; alignment

;; Program header 4: string buffer, 1 MiB
;; from 0x00500000 to 0x00600000
00000001 ; type
00000000 ; offset
=strb    ; vaddr
00000000 ; paddr
00000000 ; filesz
00100000 ; memsz 1 MiB
00000006 ; flags (no execute)
00001000 ; alignment

;; put a test string here
:tstr
"hello, World!" 00

:main   ;; entry point, it starts the repl

;; initialize the Forth stack pointer
C7 C7 00400000        ;; mov edi, 0x00400000  ; point to the top of the forth stack
;; initialize file descriptors
C7 05 =FDIN 00000000  ;; mov [FDIN], 0      ; store in FDIN
C7 05 =FDOT 00000001  ;; mov [FDOT], 1      ; store in FDOT
;; initialize free text and string space pointers
C7 C0 =EOF            ;; mov eax, =EOF      ; pointer to the end of code segment
89 05 =FTXT           ;; mov [FTXT], eax    ; store in FTXT
C7 05 =FSTR 00500000  ;; mov [FSTR], 0x00500000 ; store in FSTR
89 25 =OESP           ;; mov [OESP], edi    ; store original esp
C7 C0 =LAST           ;; mov eax, =LAST     ; pointer to the end of the word definitions
89 05 =HEAD           ;; mov [HEAD], eax    ; store in HEAD
C7 C0 =EOF            ;; mov eax, =EOF      ; pointer to the end of code segment
89 05 =FTXT           ;; mov [FTXT], eax    ; store in FTXT     

;; before we reach a repl, we may test some words here
E8 -read     ;; call read
E8 -fdwd     ;; call find-word


E8 -read     ;; call read
E8 -psnb     ;; call parse-number
E8 -read     ;; call read
E8 -steq     ;; call string==
E8 -ptst     ;; call put-string

;; E8 -repl  ;; call repl

;; call exit
C7 C0 00000001  ;; mov eax, 1       ; syscall: exit
C7 C3 00000000  ;; mov ebx, 0       ; status: 0
CD 80           ;; int 0x80         ; make syscall

;; following is the built-in Forth words
;; 1 byte for type: normal (0) or immediate (1)
;; name of the word, 0 terminated
;; 4 bytes for a pointer to the previous word (at the first byte of code)
;; the code of the word

;; dup: ( n -- n n )
00 "dup" 00
00000000 ;; pointer to previous word
:dup
8B 07           ;; mov eax, [edi]  ; get the top of stack
81 EF 00000004  ;; sub edi, 4      ; make space on stack
89 07           ;; mov [edi], eax  ; push eax onto stack
C3              ;; ret

;; drop: ( n -- )
00 "drop" 00
=dup ;; pointer to previous word
:drop
81 C7 00000004  ;; add edi, 4      ; just move the stack pointer up
C3              ;; ret

;; swap: ( n1 n2 -- n2 n1 )
00 "swap" 00
=drop ;; pointer to previous word
:swap
8B 07           ;; mov eax, [edi]      ; get n2
8B 4F 04        ;; mov ecx, [edi+4]    ; get n1
89 47 04        ;; mov [edi+4], ecx    ; put n1 to n2 position
89 0F           ;; mov [edi], eax      ; put n2 to n1 position
C3              ;; ret

;; @: ( addr -- value ) read address
00 "@" 00
=swap ;; pointer to previous word
:rdad
8B 07           ;; mov eax, [edi]      ; get addr
8B 00           ;; mov eax, [eax]      ; get value at addr
89 07           ;; mov [edi], eax     ; push value onto stack
C3              ;; ret

;; !: ( addr value -- ) write address
00 "!" 00
=rdad ;; pointer to previous word
:wtad
8B 07           ;; mov eax, [edi]      ; get value
81 C7 00000004  ;; add edi, 4          ; pop
8B 0F           ;; mov ecx, [edi]      ; get addr
89 01           ;; mov [ecx], eax      ; store value at addr
81 C7 00000004  ;; add edi, 4          ; adjust stack pointer
C3              ;; ret

;; @b: ( addr -- byte ) read byte
00 "@b" 00
=wtad ;; pointer to previous word
:rdab
8B 07           ;; mov eax, [edi]        ; get addr
0F B6 00        ;; movzx eax, byte [eax] ; get byte at addr
89 07           ;; mov [edi], eax        ; push byte onto stack
C3              ;; ret

;; !b: ( addr byte -- ) write byte
00 "!b" 00
=rdab ;; pointer to previous word
:wtab
8B 07           ;; mov eax, [edi]      ; get byte
81 C7 00000004  ;; add edi, 4          ; pop
8B 0F           ;; mov ecx, [edi]      ; get addr
88 01           ;; mov byte [ecx], al  ; store byte at addr
81 C7 00000004  ;; add edi, 4          ; adjust stack pointer
C3              ;; ret

;; get-char: ( -- char ) read a char from FDIN
00 "get-char" 00
=wtab ;; pointer to previous word
:gtch

C7 C0 00000003          ;; mov eax, 3
8B 1D =FDIN             ;; mov ebx, [FDIN]      ; file descriptor
C7 C1 =temp             ;; mov ecx, temp
C7 C2 00000001          ;; mov edx, 1
CD 80                   ;; int 0x80

;; if read EOF, return -1
81 F8 00000000          ;; cmp eax, 0
0F 84 -reof             ;; je reof
8B 05 =temp             ;; mov eax, [temp]
81 EF 00000004          ;; sub edi, 4        ; make space on stack
89 07                   ;; mov [edi], eax    ; push eax onto stack
C3                      ;; ret
:reof
81 EF 00000004          ;; sub edi, 4        ; make space on stack
C7 07 FFFFFFFF          ;; mov [edi], 0xFFFFFFFF     ; push -1 onto stack
C3                      ;; ret

;; put-char: ( char -- ) write a char to FDOT
00 "put-char" 00
=gtch ;; pointer to previous word
:ptch
8B 07                   ;; mov eax, [edi]       ; get the char to write
81 C7 00000004          ;; add edi, 4           ; pop
C7 C0 00000004          ;; mov eax, 4           ; syscall: write
8B 1D =FDOT             ;; mov ebx, [FDOT]      ; file descriptor
89 F9                   ;; mov ecx, edi         ; buffer to write
C7 C2 00000001          ;; mov edx, 1           ; write 1 byte
CD 80                   ;; int 0x80             ; make syscall
C3                      ;; ret

;; put-string: ( addr -- ) write a string to FDOT
00 "put-string" 00
=ptch ;; pointer to previous word
:ptst
8B 0F                   ;; mov ecx, [edi]       ; get the addr of string
81 C7 00000004          ;; add edi, 4           ; pop
;; count length in edx
C7 C2 FFFFFFFF          ;; mov edx, 0xFFFFFFFF  ; edx = -1
:lcnt
81 C2 00000001          ;; add edx, 1           ; edx++
0F B6 18                ;; movzx ebx, [eax]     ; get a byte
81 C0 00000001          ;; add eax, 1           ; point to next byte
81 FB 00000000          ;; cmp ebx, 0           ; check for null terminator
0F 85 -lcnt             ;; jne lcnt             ; if not null, continue
;; write the string
C7 C0 00000004          ;; mov eax, 4           ; syscall: write
8B 1D =FDOT             ;; mov ebx, [FDOT]      ; file descriptor
;; ecx already has the buffer address
;; edx already has the length
CD 80                   ;; int 0x80             ; make syscall
C3                      ;; ret

;; head@: ( -- addr ) get the latest defined word address
00 "head@" 00
=ptst ;; pointer to previous word
:hdat
81 EF 00000004         ;; sub edi, 4           ; make space on stack
C7 07 =HEAD            ;; mov [edi], HEAD      ; get HEAD
C3                     ;; ret

;; free@: ( -- addr ) get the free text space pointer
00 "free@" 00
=hdat ;; pointer to previous word
:ftat
81 EF 00000004         ;; sub edi, 4           ; make space on stack
C7 07 =FTXT            ;; mov [edi], FTXT      ; get FTXT
C3                     ;; ret

;; old-esp@: ( -- addr ) get the original esp
00 "old-esp@" 00
=ftat ;; pointer to previous word
:oesp
81 EF 00000004        ;; sub edi, 4           ; make space on stack
C7 07 =OESP           ;; mov [edi], OESP      ; push OESP onto stack
C3                    ;; ret

;; fd-in@: ( -- fd ) get FDIN
00 "fd-in@" 00
=oesp ;; pointer to previous word
:fdin
81 EF 00000004        ;; sub edi, 4           ; make space on stack
C7 07 =FDIN           ;; mov [edi], FDIN      ; push FDIN onto stack
C3                    ;; ret

;; fd-out@: ( -- fd ) get FDOT
00 "fd-out@" 00
=fdin ;; pointer to previous word
:fdot
81 EF 00000004        ;; sub edi, 4           ; make space on stack
C7 07 =FDOT           ;; mov [edi], FDOT      ; push FDOT onto stack
C3                    ;; ret

;; stack-min@: ( -- addr ) get the minimum address of the forth stack
00 "stack-min@" 00
=fdot ;; pointer to previous word
:smin
81 EF 00000004       ;; sub edi, 4           ; make space on stack
C7 07 =fstk          ;; mov [edi], fstk      ; push onto stack
C3                   ;; ret

;; stack-size: ( -- size ) get the size of the forth stack
00 "stack-size" 00
=smin ;; pointer to previous word
:stsz
81 EF 00000004       ;; sub edi, 4           ; make space on stack
C7 07 =fstz          ;; mov [edi], fstz      ; push onto stack
C3                   ;; ret

;; stack-curr@: ( -- addr ) get the current top address of the forth stack
00 "stack-curr@" 00
=stsz ;; pointer to previous word
:stcr 
89 F8                ;; mov eax, edi         ; get current top of forth stack
81 EF 00000004       ;; sub edi, 4           ; make space on stack
89 07                ;; mov [edi], eax       ; push onto stack
C3                   ;; ret

;; read: ( -- string ) read a line from FDIN into string buffer
;; if EOF, return 0
;; skip leading whitespaces 
;; terminate at first whitespace
00 "read" 00
=stcr ;; pointer to previous word
:read
;; save the starting address of string buffer
8B 05 =FSTR       ;; mov eax, [FSTR]
50                ;; push eax
;; read characters into string buffer
:rlpA   ;; read loop A: skip leading whitespaces
E8 -gtch         ;; call get-char       ; ( addr char )
8B 07            ;; mov eax, [edi]      ; get char
81 C7 00000004   ;; add edi, 4          ; remember to pop
81 F8 FFFFFFFF   ;; cmp eax, -1         ; check for EOF
0F 84 -Reof      ;; je Reof             ; if EOF, finish

:rdsp
81 F8 00000020   ;; cmp eax, 0x20       ; check for whitespace
0F 86 -rlpA      ;; jbe rlpA             ; if whitespace, goto loop

;; store the character into string buffer
:rlpB    ;; read loop B: store characters
8B 0D =FSTR          ;; mov ecx, [FSTR]     ; get string buffer pointer
88 01                ;; mov byte [ecx], al  ; store the character
81 05 =FSTR 00000001 ;; add dword [FSTR], 1 ; increment string buffer pointer
E8 -gtch             ;; call get-char       ; ( addr char )
8B 07                ;; mov eax, [edi]      ; get char
81 C7 00000004       ;; add edi, 4          ; pop
81 F8 00000020       ;; cmp eax, 0x20       ; check for whitespace (also EOF)
0F 87 -rlpB          ;; ja rlpB             ; if not whitespace, continue loop

;; terminate the string
8B 0D =FSTR          ;; mov ecx, [FSTR]     ; get string buffer pointer
C6 01 00             ;; mov byte ;[ecx], 0   ; null terminate
81 05 =FSTR 00000001 ;; add dword [FSTR], 1 ; point to next free space
;; pop the starting address of string buffer
58                   ;; pop eax
;; push the address onto stack
81 EF 00000004       ;; sub edi, 4           ; make space on stack
89 07                ;; mov [edi], eax       ; push address onto stack
C3                   ;; ret

:Reof   ;; carefully avoid label conflict
81 EF 00000004       ;; sub edi, 4           ; make space on stack
C7 07 00000000       ;; mov [edi], 0
58                   ;; pop eax         ; clean up stack
C3                   ;; ret

;; string==: ( addr1 addr2 -- flag ) compare two strings
;; return 1 if equal, 0 if not equal
00 "string==" 00
=read ;; pointer to previous word
:steq
8B 07            ;; mov eax, [edi]      ; get addr2
81 C7 00000004   ;; add edi, 4          ; pop
8B 0F            ;; mov ecx, [edi]      ; get addr1
81 C7 00000004   ;; add edi, 4          ; pop

:seql   ;; string equal loop, compare byte by byte
0F B6 10       ;; movzx edx, byte [eax]  ; get byte from addr2
0F B6 19       ;; movzx ebx, byte [ecx]  ; get byte from addr1

81 FA 00000000 ;; cmp edx, 0             ; check for null terminator
0F 84 -sdnl    ;; je sdnl                ; if null, goto string d null
3B DA          ;; cmp ebx, edx           ; compare the two bytes
0F 85 -seqz    ;; jne seqz               ; if not equal, goto strings not equal
81 C0 00000001 ;; add eax, 1             ; point to next byte in addr2
81 C1 00000001 ;; add ecx, 1             ; point to next byte in addr1
E9 -seql       ;; jmp seql               ; continue loop

:sdnl   ;; string d ends, check string b
81 FB 00000000 ;; cmp ebx, 0             ; check for null terminator
0F 84 -seqo    ;; je seqo                ; if null, goto string equal one
;; otherwise, strings not equal

:seqz   ;; strings not equal
81 EF 00000004 ;; sub edi, 4         ; make space on stack
C7 07 00000000 ;; mov [edi], 0       ; push 0 onto stack
C3             ;; ret

:seqo   ;; strings equal
81 EF 00000004 ;; sub edi, 4         ; make space on stack
C7 07 00000001 ;; mov [edi], 1       ; push 1 onto stack
C3             ;; ret

;; parse-number: ( addr -- number ok ) parse a number from string
;; support decimal and hexadecimal (prefix 0x)
;; return the number and ok 1 if successful, ok 0 if not a number 
00 "parse-number" 00
=steq ;; pointer to previous word
:psnb
8B 07            ;; mov eax, [edi]     ; get addr
81 C7 00000004   ;; add edi, 4         ; pop

;check if hexadecimal
0F B6 18        ;; movzx ebx, byte [eax]  ; get first char

81 FB 00000030  ;; cmp ebx, '0'        ; check first char '0'
0F 85 -pnnh     ;; jne pnnh            ; if not '0', parse-number not hex
0F B6 58 01     ;; movzx ebx, byte [eax+1] ; get second char
81 FB 000000"x" ;; cmp ebx, 'x'        ; check second char 'x'
0F 85 -pnnh     ;; jne pnnh            ; if not 'x', parse-number not hex
;; eax for addr, ebx for base
;; it's hexadecimal
C7 C3 00000010  ;; mov ebx, 16        ; base 16
81 C0 00000002  ;; add eax, 2         ; point to first digit  
E9 -pnLP        ;; jmp pnLP

;; it's decimal
:pnnh   ;; parse-number not hex
C7 C3 0000000A  ;; mov ebx, 10        ; base 10

:pnLP  ;; parse-number loop with initialization
81 EF 00000004  ;; sub edi, 4       ; make space on stack
C7 07 00000000  ;; mov [edi], 0     ; push 0 onto stack for the result

:pnlp   ;; parse-number loop
0F B6 08        ;; movzx ecx, byte [eax]  ; get current char

;; check for end of string
81 F9 00000000  ;; cmp ecx, 0             ; check for null terminator
0F 84 -pnok     ;; je pnok                ; if null, finish parsing

81 EF 00000004  ;; sub edi, 4             ; make space on stack
89 0F           ;; mov [edi], ecx         ; push char onto stack
81 C0 00000001  ;; add eax, 1             ; point to next char

50 53           ;; push eax, ebx, save registers
E8 -psdg        ;; call parse-digit    ; ( char -- digit )
8B 0F           ;; mov ecx, [edi]      ; get current digit
81 F9 FFFFFFFF  ;; cmp ecx, 0xFFFFFFFF ; check if -1
0F 84 -pner     ;; je pner             ; if -1, not a digit

;; got a digit, update the number
5b 58           ;; pop ebx, eax           ; recover registers

;; check if digit is valid (ecx: digit < ebx: base)
39 D9           ;; cmp ecx, ebx           ; compare digit with base
0F 8D -pnER     ;; jge pnER               ; if digit >= base, error

81 C7 00000004  ;; add edi, 4             ; pop

8B 17           ;; mov edx, [edi]         ; get current number
0F AF D3        ;; imul edx, ebx          ; number * base
01 CA           ;; add edx, ecx           ; number + digit
89 17           ;; mov [edi], edx         ; update number
E9 -pnlp        ;; jmp pnlp

:pner   ;; parse-number error
58 58           ;; pop ebx, eax           ; recover stack
:pnER   ;; parse-number error, without cleaning up stack
;; HACK: we don't need edi-=4, because we will overwrite the char on stack
C7 07 00000000  ;; mov [edi], 0           ; push 0 (not ok) onto stack
C3              ;; ret

:pnok   ;; parse-number ok
81 EF 00000004  ;; sub edi, 4             ; make space on stack
C7 07 00000001  ;; mov [edi], 1           ; push 1 (ok) onto stack
C3              ;; ret

;; parse-digit: (char -- digit)  parse a digit, return -1 if not a digit
00 "parse-digit" 00
=psnb ;; pointer to previous word
:psdg
8B 07            ;; mov eax, [edi]      ; get char
81 C7 00000004   ;; add edi, 4          ; pop

81 F8 000000"0"  ;; cmp eax, '0'     ; check if '0' <= ch
0F 8C -pdnd      ;; jl pdnd          ; if ch < '0', not digit
81 F8 000000"9"  ;; cmp eax, '9'     ; check if ch <= '9'
0F 8F -pdnd      ;; jg pdnd          ; if ch > '9', not digit
;; it's a digit
81 E8 000000"0"  ;; sub eax, '0'     ; convert to number
E9 -pret         ;; jmp pret

:pdnd  ;; not a digit, is it a-f or A-F?
81 F8 000000"a"  ;; cmp eax, 'a'     ; check if 'a' <= ch
0F 8C -pnaf      ;; jl pnaf          ; if ch < 'a', not a-f
81 F8 000000"f"  ;; cmp eax, 'f'     ; check if ch <= 'f'
0F 8F -pnaf      ;; jg pnaf          ; if ch > 'f', not a-f
;; it's a-f
81 E8 000000"a"  ;; sub eax, 'a'     ; convert to number
81 C0 0000000A   ;; add eax, 10      ; add 10
E9 -pret         ;; jmp pret

:pnaf  ;; not a digit or a-f, is it A-F?
81 F8 000000"A"  ;; cmp eax, 'A'     ; check if 'A' <= ch
0F 8C -pnaA      ;; jl pnaA          ; if ch < 'A', not A-F
81 F8 000000"F"  ;; cmp eax, 'F'     ; check if ch <= 'F'
0F 8F -pnaA      ;; jg pnaA          ; if ch > 'F', not A-F 
;; it's A-F
81 E8 000000"A"  ;; sub eax, 'A'     ; convert to number
81 C0 0000000A   ;; add eax, 10      ; add 10
E9 -pret         ;; jmp pret

:pret
81 EF 00000004   ;; sub edi, 4       ; make space on stack
89 07            ;; mov [edi], eax   ; push number onto stack
C3               ;; ret

:pnaA  ;; not a digit or a-f or A-F, return -1
81 EF 00000004  ;; sub edi, 4                ; make space on stack
C7 07 FFFFFFFF  ;; mov [edi], 0xFFFFFFFF     ; push -1 onto stack
C3              ;; ret

;; find-word: ( addr -- wordptr immediate ) find a word by its name
;; return wordptr and immediate flag, if not found, return 0 0
00 "find-word" 00
=psdg ;; pointer to previous word
:fdwd
:LAST
8B 07            ;; mov eax, [edi]      ; get addr (name to find)
81 C7 00000004   ;; add edi, 4          ; pop

8B 0D =HEAD      ;; mov ecx, [HEAD]     ; get latest defined word

81 EF 00000004   ;; sub edi, 4          ; make space on stack
89 0F            ;; mov [edi], ecx      ; push current word ptr onto stack

:fwlp   ;; find-word loop
;; eax: name to find, edx: name of current word
81 F9 00000000   ;; cmp ecx, 0           ; check for null
0F 84 -fwnf      ;; je fwnf              ; if null, not found

E8 -fwnm         ;; call find word name ; return addr in edx

81 EF 00000004   ;; sub edi, 4           ; make space on stack
89 07            ;; mov [edi], eax       ; push addr of name to find
81 EF 00000004   ;; sub edi, 4           ; make space on stack
89 17            ;; mov [edi], edx       ; push addr of name of current word

50 52            ;; push eax, edx        ; save registers
E8 -steq         ;; call string==        ; compare the two strings
8B 1F            ;; mov ebx, [edi]       ; get flag
81 C7 00000004   ;; add edi, 4           ; pop

5a 58            ;; pop edx, eax         ; recover registers

81 FB 00000000   ;; cmp ebx, 0           ; check if equal
0F 85 -fwfd      ;; jne fwlp             ; if equal, done

8B 0F            ;; mov ecx, [edi]       ; get current word ptr
8B 49 FC         ;; mov ecx, [ecx-4]     ; get previous word ptr
89 0F            ;; mov [edi], ecx       ; push current word ptr onto stack

E9 -fwlp         ;; jmp fwlp             ; continue loop

:fwfd  ;; found the word
81 EA 00000001   ;; sub edx, 1           ; point to immediate flag
0F B6 0A         ;; movzx ecx, byte [edx]; get a byte of flag
81 EF 00000004   ;; sub edi, 4           ; make space on stack
89 0F            ;; mov [edi], ecx       ; push immediate flag
C3               ;; ret

81 E9 00000004   ;; sub ecx, 4          ; point to previous word field
8B 09            ;; mov ecx, [ecx]      ; get previous word ptr

:fwnf  ;; find-word not found
81 EF 00000004   ;; sub edi, 4          ; make space on stack
C7 07 00000000   ;; mov [edi], 0        ; push 0, not found
C3               ;; ret

:fwnm  ;; find the name of current word
;; ecx: current word ptr, edx: return addr
51             ;; pushj ecx            ; save ecx

89 CA          ;; mov edx, ecx         ; edx = current word ptr
81 EA 00000006 ;; sub edx, 6           ; point to the last byte of name
:fwnl
0F B6 0A       ;; movzx ecx, byte [edx]  ; get a byte of name
81 F9 00000001 ;; cmp ecx, 1             ; check for null 
0F 86 -fwne    ;; jbe fwne               ; if null, finish name extraction

81 EA 00000001 ;; sub edx, 1             ; point to previous byte
E9 -fwnl       ;; jmp fwnl               ; continue loop

:fwne
59             ;; pop ecx                ; recover ecx
81 C2 00000001 ;; add edx, 1             ; point to first byte of name
C3             ;; ret


:EOF ; need one whitespace after last label

