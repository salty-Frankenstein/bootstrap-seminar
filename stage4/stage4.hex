;; Implement a basic Forth interpreter using stage3

;; Set up labels for variables and segments:
00200000@ :glbl  ; global variables
00300000@ :fstk  ; forth stack

;; text segment starts at virtual address 00010000
00010000@ :text

;; ELF header:
7F "ELF" 01 01 01 00
00 00 00 00 00 00 00 00

0002     ; type
0003     ; machine
00000000 ; version
=main    ; entry
$PH      ; phoff (00000034)
00000000 ; shoff
00000000 ; flags
0034     ; ehsize
0020     ; phentsize
0003     ; phnum (3)
0000     ; shentsize
0000     ; shnum
0000     ; shstrndx

:PH
;; Program header 1: the program text.
;; It also contains the words to be loaded later.
00000001 ; type
00000000 ; offset
=text    ; vaddr
00000000 ; paddr
$EOF     ; filesz
00100000 ; memsz 1 MiB
00000007 ; flags
00001000 ; alignment

;; Program header 2: global variables, 4 KiB
00000001 ; type
00000000 ; offset
=glbl    ; vaddr
00000000 ; paddr
00000000 ; filesz
00001000 ; memsz 4 KiB
00000006 ; flags (no execute)
00001000 ; alignment

;; Program header 3: forth stack, 1 MiB
;; from 0x00300000 to 0x00400000
;; the stack pointer is edi, pointed to 0x00400000 initialialy
00000001 ; type
00000000 ; offset
=fstk    ; vaddr
00000000 ; paddr
00000000 ; filesz
00100000 ; memsz 1 MiB
00000006 ; flags (no execute)
00001000 ; alignment

:main   ;; entry point, it starts the repl

;; initialize the Forth stack pointer
C7 C7 00400000  ;; mov edi, 0x00400000  ; point to the top of the forth stack

;; before we reach a repl, we may test some words here

;; test ! and @, !b and @b
81 EF 00000004  ;; sub edi, 4      ; make space on stack
C7 C0 =glbl     ;; mov eax, =glbl  ; push address of a global variable
89 07           ;; mov [edi], eax  

E8 -dup      ;; call dup    (addr addr)

81 EF 00000004  ;; sub edi, 4            ; make space on stack
C7 C0 c0ffeeab  ;; mov eax, 0xc0ffeeab   ; push a 0xc0ffeeab 
89 07           ;; mov [edi], eax  (addr addr 0xc0ffeeab) 
E8 -wtad     ;; call !                   ; glbl <- 0xc0ffeeab ( addr )

E8 -dup      ;; call dup    (addr addr)
81 EF 00000004  ;; sub edi, 4            ; make space on stack
C7 C0 00000042  ;; mov eax, 0x42         ; push a 0x42 
89 07           ;; mov [edi], eax  (addr addr 0x42) 

E8 -wtab     ;; call !b               ; glbl[0] <- 0x42 ( addr )
;; glbl = 0xc0ffeeab -> 0xc0ffee42

E8 -dup      ;; call dup    (addr addr)
E8 -rdab     ;; call @b               ; push glbl[0] ( addr 0x42 )
E8 -swap     ;; call swap             ; ( 0x42 addr )

E8 -rdad     ;; call @         ; ( 0x42 0xc0ffee42 )

;; E8 -repl  ;; call repl

;; call exit
C7 C0 00000001  ;; mov eax, 1       ; syscall: exit
C7 C3 00000000  ;; mov ebx, 0       ; status: 0
CD 80           ;; int 0x80         ; make syscall

;; following is the built-in Forth words
;; 1 byte for type: normal (0) or immediate (1)
;; name of the word, 0 terminated
;; 4 bytes for a pointer to the previous word (at the first byte of code)
;; the code of the word

;; dup: ( n -- n n )
00 "dup" 00
00000000 ;; pointer to previous word
:dup
8B 07           ;; mov eax, [edi]  ; get the top of stack
81 EF 00000004  ;; sub edi, 4      ; make space on stack
89 07           ;; mov [edi], eax  ; push eax onto stack
C3              ;; ret

;; drop: ( n -- )
00 "drop" 00
=dup ;; pointer to previous word
:drop
81 C7 00000004  ;; add edi, 4      ; just move the stack pointer up
C3              ;; ret

;; swap: ( n1 n2 -- n2 n1 )
00 "swap" 00
=drop ;; pointer to previous word
:swap
8B 07           ;; mov eax, [edi]      ; get n2
8B 4F 04        ;; mov ecx, [edi+4]    ; get n1
89 47 04        ;; mov [edi+4], ecx    ; put n1 to n2 position
89 0F           ;; mov [edi], eax      ; put n2 to n1 position
C3              ;; ret

;; @: ( addr -- value ) read address
00 "@" 00
=swap ;; pointer to previous word
:rdad
8B 07           ;; mov eax, [edi]      ; get addr
8B 00           ;; mov eax, [eax]      ; get value at addr
89 07           ;; mov [edi], eax     ; push value onto stack
C3              ;; ret

;; !: ( addr value -- ) write address
00 "!" 00
=rdad ;; pointer to previous word
:wtad
8B 07           ;; mov eax, [edi]      ; get value
81 C7 00000004  ;; add edi, 4          ; pop
8B 0F           ;; mov ecx, [edi]      ; get addr
89 01           ;; mov [ecx], eax      ; store value at addr
81 C7 00000004  ;; add edi, 4          ; adjust stack pointer
C3              ;; ret

;; @b: ( addr -- byte ) read byte
00 "@b" 00
=wtad ;; pointer to previous word
:rdab
8B 07           ;; mov eax, [edi]        ; get addr
0F B6 00        ;; movzx eax, byte [eax] ; get byte at addr
89 07           ;; mov [edi], eax        ; push byte onto stack
C3              ;; ret

;; !b: ( addr byte -- ) write byte
00 "!b" 00
=rdab ;; pointer to previous word
:wtab
8B 07           ;; mov eax, [edi]      ; get byte
81 C7 00000004  ;; add edi, 4          ; pop
8B 0F           ;; mov ecx, [edi]      ; get addr
88 01           ;; mov byte [ecx], al  ; store byte at addr
81 C7 00000004  ;; add edi, 4          ; adjust stack pointer
C3              ;; ret

:EOF ; need one whitespace after last label
