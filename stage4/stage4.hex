;; Implement a basic Forth interpreter using stage3

;; Set up labels for variables and segments:
00200000@ :glbl  ; global variables
00200004@ :FDIN  ; file descriptor for input
00200008@ :FDOT  ; file descriptor for output
0020000C@ :FTXT  ; pointer to free text space
00200010@ :FSTR  ; pointer to free string space
00200014@ :HEAD  ; pointer to the latest defined word
00200018@ :OESP  ; original esp 


00200020@ :temp  ; temporary variable for internal use
00300000@ :fstk  ; forth stack
00100000@ :fstz  ; forth stack size
00500000@ :strb  ; string buffer

;; text segment starts at virtual address 00010000
00010000@ :text

;; ELF header:
7F "ELF" 01 01 01 00
00 00 00 00 00 00 00 00

0002     ; type
0003     ; machine
00000000 ; version
=main    ; entry
$PH      ; phoff (00000034)
00000000 ; shoff
00000000 ; flags
0034     ; ehsize
0020     ; phentsize
0004     ; phnum (4)
0000     ; shentsize
0000     ; shnum
0000     ; shstrndx

:PH
;; Program header 1: the program text.
;; It also contains the words to be loaded later.
00000001 ; type
00000000 ; offset
=text    ; vaddr
00000000 ; paddr
$EOF     ; filesz
00100000 ; memsz 1 MiB
00000007 ; flags
00001000 ; alignment

;; Program header 2: global variables, 4 KiB
00000001 ; type
00000000 ; offset
=glbl    ; vaddr
00000000 ; paddr
00000000 ; filesz
00001000 ; memsz 4 KiB
00000006 ; flags (no execute)
00001000 ; alignment

;; Program header 3: forth stack, 1 MiB
;; from 0x00300000 to 0x00400000
;; the stack pointer is edi, pointed to 0x00400000 initialialy
00000001 ; type
00000000 ; offset
=fstk    ; vaddr
00000000 ; paddr
00000000 ; filesz
00100000 ; memsz 1 MiB
00000006 ; flags (no execute)
00001000 ; alignment

;; Program header 4: string buffer, 1 MiB
;; from 0x00500000 to 0x00600000
00000001 ; type
00000000 ; offset
=strb    ; vaddr
00000000 ; paddr
00000000 ; filesz
00100000 ; memsz 1 MiB
00000006 ; flags (no execute)
00001000 ; alignment

;; put a test string here
:tstr
"hello, World!" 00

:main   ;; entry point, it starts the repl

;; initialize the Forth stack pointer
C7 C7 00400000        ;; mov edi, 0x00400000  ; point to the top of the forth stack
;; initialize file descriptors
C7 05 =FDIN 00000000  ;; mov [FDIN], 0      ; store in FDIN
C7 05 =FDOT 00000001  ;; mov [FDOT], 1      ; store in FDOT
;; initialize free text and string space pointers
C7 C0 =EOF            ;; mov eax, =EOF      ; pointer to the end of code segment
89 05 =FTXT           ;; mov [FTXT], eax    ; store in FTXT
C7 05 =FSTR 00500000  ;; mov [FSTR], 0x00500000 ; store in FSTR
89 25 =OESP           ;; mov [OESP], edi    ; store original esp
C7 C0 =LAST           ;; mov eax, =LAST     ; pointer to the end of the word definitions
89 05 =HEAD           ;; mov [HEAD], eax    ; store in HEAD
C7 C0 =EOF            ;; mov eax, =EOF      ; pointer to the end of code segment
89 05 =FTXT           ;; mov [FTXT], eax    ; store in FTXT     

;; before we reach a repl, we may test some words here
E8 -repl  ;; call repl

;; call exit
C7 C0 00000001  ;; mov eax, 1       ; syscall: exit
C7 C3 00000000  ;; mov ebx, 0       ; status: 0
CD 80           ;; int 0x80         ; make syscall

;; following is the built-in Forth words
;; 1 byte for type: normal (0) or immediate (1)
;; name of the word, 0 terminated
;; 4 bytes for a pointer to the previous word (at the first byte of code)
;; the code of the word

;; dup: ( n -- n n )
00 "dup" 00
00000000 ;; pointer to previous word
:dup
8B 07           ;; mov eax, [edi]  ; get the top of stack
81 EF 00000004  ;; sub edi, 4      ; make space on stack
89 07           ;; mov [edi], eax  ; push eax onto stack
C3              ;; ret

;; drop: ( n -- )
00 "drop" 00
=dup ;; pointer to previous word
:drop
81 C7 00000004  ;; add edi, 4      ; just move the stack pointer up
C3              ;; ret

;; swap: ( n1 n2 -- n2 n1 )
00 "swap" 00
=drop ;; pointer to previous word
:swap
8B 07           ;; mov eax, [edi]      ; get n2
8B 4F 04        ;; mov ecx, [edi+4]    ; get n1
89 47 04        ;; mov [edi+4], ecx    ; put n1 to n2 position
89 0F           ;; mov [edi], eax      ; put n2 to n1 position
C3              ;; ret

;; @: ( addr -- value ) read address
00 "@" 00
=swap ;; pointer to previous word
:rdad
8B 07           ;; mov eax, [edi]      ; get addr
8B 00           ;; mov eax, [eax]      ; get value at addr
89 07           ;; mov [edi], eax     ; push value onto stack
C3              ;; ret

;; !: ( addr value -- ) write address
00 "!" 00
=rdad ;; pointer to previous word
:wtad
8B 07           ;; mov eax, [edi]      ; get value
81 C7 00000004  ;; add edi, 4          ; pop
8B 0F           ;; mov ecx, [edi]      ; get addr
89 01           ;; mov [ecx], eax      ; store value at addr
81 C7 00000004  ;; add edi, 4          ; adjust stack pointer
C3              ;; ret

;; @b: ( addr -- byte ) read byte
00 "@b" 00
=wtad ;; pointer to previous word
:rdab
8B 07           ;; mov eax, [edi]        ; get addr
0F B6 00        ;; movzx eax, byte [eax] ; get byte at addr
89 07           ;; mov [edi], eax        ; push byte onto stack
C3              ;; ret

;; !b: ( addr byte -- ) write byte
00 "!b" 00
=rdab ;; pointer to previous word
:wtab
8B 07           ;; mov eax, [edi]      ; get byte
81 C7 00000004  ;; add edi, 4          ; pop
8B 0F           ;; mov ecx, [edi]      ; get addr
88 01           ;; mov byte [ecx], al  ; store byte at addr
81 C7 00000004  ;; add edi, 4          ; adjust stack pointer
C3              ;; ret

;; get-char: ( -- char ) read a char from FDIN
00 "get-char" 00
=wtab ;; pointer to previous word
:gtch

C7 C0 00000003          ;; mov eax, 3
8B 1D =FDIN             ;; mov ebx, [FDIN]      ; file descriptor
C7 C1 =temp             ;; mov ecx, temp
C7 C2 00000001          ;; mov edx, 1
CD 80                   ;; int 0x80

;; if read EOF, return -1
81 F8 00000000          ;; cmp eax, 0
0F 84 -reof             ;; je reof
8B 05 =temp             ;; mov eax, [temp]
81 EF 00000004          ;; sub edi, 4        ; make space on stack
89 07                   ;; mov [edi], eax    ; push eax onto stack
C3                      ;; ret
:reof
81 EF 00000004          ;; sub edi, 4        ; make space on stack
C7 07 FFFFFFFF          ;; mov [edi], 0xFFFFFFFF     ; push -1 onto stack
C3                      ;; ret

;; put-char: ( char -- ) write a char to FDOT
00 "put-char" 00
=gtch ;; pointer to previous word
:ptch
C7 C0 00000004          ;; mov eax, 4           ; syscall: write
8B 1D =FDOT             ;; mov ebx, [FDOT]      ; file descriptor
89 F9                   ;; mov ecx, edi         ; buffer to write
C7 C2 00000001          ;; mov edx, 1           ; write 1 byte
CD 80                   ;; int 0x80             ; make syscall
81 C7 00000004          ;; add edi, 4           ; pop
C3                      ;; ret

;; put-string: ( addr -- ) write a string to FDOT
00 "put-string" 00
=ptch ;; pointer to previous word
:ptst
8B 0F                   ;; mov ecx, [edi]       ; get the addr of string
81 C7 00000004          ;; add edi, 4           ; pop
;; count length in edx
C7 C2 FFFFFFFF          ;; mov edx, 0xFFFFFFFF  ; edx = -1
89 C8                   ;; mov eax, ecx         ; eax = addr
:lcnt
81 C2 00000001          ;; add edx, 1           ; edx++
0F B6 18                ;; movzx ebx, [eax]     ; get a byte
81 C0 00000001          ;; add eax, 1           ; point to next byte
81 FB 00000000          ;; cmp ebx, 0           ; check for null terminator
0F 85 -lcnt             ;; jne lcnt             ; if not null, continue
;; write the string
C7 C0 00000004          ;; mov eax, 4           ; syscall: write
8B 1D =FDOT             ;; mov ebx, [FDOT]      ; file descriptor
;; ecx already has the buffer address
;; edx already has the length
CD 80                   ;; int 0x80             ; make syscall
C3                      ;; ret

;; head@: ( -- addr ) get the latest defined word address
00 "head@" 00
=ptst ;; pointer to previous word
:hdat
81 EF 00000004         ;; sub edi, 4           ; make space on stack
C7 07 =HEAD            ;; mov [edi], HEAD      ; get HEAD
C3                     ;; ret

;; free@: ( -- addr ) get the free text space pointer
00 "free@" 00
=hdat ;; pointer to previous word
:ftat
81 EF 00000004         ;; sub edi, 4           ; make space on stack
C7 07 =FTXT            ;; mov [edi], FTXT      ; get FTXT
C3                     ;; ret

;; old-esp@: ( -- addr ) get the original esp
00 "old-esp@" 00
=ftat ;; pointer to previous word
:oesp
81 EF 00000004        ;; sub edi, 4           ; make space on stack
C7 07 =OESP           ;; mov [edi], OESP      ; push OESP onto stack
C3                    ;; ret

;; fd-in@: ( -- fd ) get FDIN
00 "fd-in@" 00
=oesp ;; pointer to previous word
:fdin
81 EF 00000004        ;; sub edi, 4           ; make space on stack
C7 07 =FDIN           ;; mov [edi], FDIN      ; push FDIN onto stack
C3                    ;; ret

;; fd-out@: ( -- fd ) get FDOT
00 "fd-out@" 00
=fdin ;; pointer to previous word
:fdot
81 EF 00000004        ;; sub edi, 4           ; make space on stack
C7 07 =FDOT           ;; mov [edi], FDOT      ; push FDOT onto stack
C3                    ;; ret

;; stack-min@: ( -- addr ) get the minimum address of the forth stack
00 "stack-min@" 00
=fdot ;; pointer to previous word
:smin
81 EF 00000004       ;; sub edi, 4           ; make space on stack
C7 07 =fstk          ;; mov [edi], fstk      ; push onto stack
C3                   ;; ret

;; stack-size: ( -- size ) get the size of the forth stack
00 "stack-size" 00
=smin ;; pointer to previous word
:stsz
81 EF 00000004       ;; sub edi, 4           ; make space on stack
C7 07 =fstz          ;; mov [edi], fstz      ; push onto stack
C3                   ;; ret

;; stack-curr@: ( -- addr ) get the current top address of the forth stack
00 "stack-curr@" 00
=stsz ;; pointer to previous word
:stcr 
89 F8                ;; mov eax, edi         ; get current top of forth stack
81 EF 00000004       ;; sub edi, 4           ; make space on stack
89 07                ;; mov [edi], eax       ; push onto stack
C3                   ;; ret

;; read: ( -- string ) read a line from FDIN into string buffer
;; if EOF, return 0
;; skip leading whitespaces 
;; terminate at first whitespace
00 "read" 00
=stcr ;; pointer to previous word
:read
;; save the starting address of string buffer
8B 05 =FSTR       ;; mov eax, [FSTR]
50                ;; push eax
;; read characters into string buffer
:rlpA   ;; read loop A: skip leading whitespaces
E8 -gtch         ;; call get-char       ; ( addr char )
8B 07            ;; mov eax, [edi]      ; get char
81 C7 00000004   ;; add edi, 4          ; remember to pop
81 F8 FFFFFFFF   ;; cmp eax, -1         ; check for EOF
0F 84 -Reof      ;; je Reof             ; if EOF, finish

:rdsp
81 F8 00000020   ;; cmp eax, 0x20       ; check for whitespace
0F 8E -rlpA      ;; jle rlpA             ; if whitespace, goto loop

;; store the character into string buffer
:rlpB    ;; read loop B: store characters
8B 0D =FSTR          ;; mov ecx, [FSTR]     ; get string buffer pointer
88 01                ;; mov byte [ecx], al  ; store the character
81 05 =FSTR 00000001 ;; add dword [FSTR], 1 ; increment string buffer pointer
E8 -gtch             ;; call get-char       ; ( addr char )
8B 07                ;; mov eax, [edi]      ; get char
81 C7 00000004       ;; add edi, 4          ; pop
81 F8 00000020       ;; cmp eax, 0x20       ; check for whitespace (also EOF)
0F 8F -rlpB          ;; jg rlpB             ; if not whitespace, continue loop

;; terminate the string
8B 0D =FSTR          ;; mov ecx, [FSTR]     ; get string buffer pointer
C6 01 00             ;; mov byte ;[ecx], 0   ; null terminate
81 05 =FSTR 00000001 ;; add dword [FSTR], 1 ; point to next free space
;; pop the starting address of string buffer
58                   ;; pop eax
;; push the address onto stack
81 EF 00000004       ;; sub edi, 4           ; make space on stack
89 07                ;; mov [edi], eax       ; push address onto stack
C3                   ;; ret

:Reof   ;; carefully avoid label conflict
81 EF 00000004       ;; sub edi, 4           ; make space on stack
C7 07 00000000       ;; mov [edi], 0
58                   ;; pop eax         ; clean up stack
C3                   ;; ret

;; string==: ( addr1 addr2 -- flag ) compare two strings
;; return 1 if equal, 0 if not equal
00 "string==" 00
=read ;; pointer to previous word
:steq
8B 07            ;; mov eax, [edi]      ; get addr2
81 C7 00000004   ;; add edi, 4          ; pop
8B 0F            ;; mov ecx, [edi]      ; get addr1
81 C7 00000004   ;; add edi, 4          ; pop

:seql   ;; string equal loop, compare byte by byte
0F B6 10       ;; movzx edx, byte [eax]  ; get byte from addr2
0F B6 19       ;; movzx ebx, byte [ecx]  ; get byte from addr1

81 FA 00000000 ;; cmp edx, 0             ; check for null terminator
0F 84 -sdnl    ;; je sdnl                ; if null, goto string d null
3B DA          ;; cmp ebx, edx           ; compare the two bytes
0F 85 -seqz    ;; jne seqz               ; if not equal, goto strings not equal
81 C0 00000001 ;; add eax, 1             ; point to next byte in addr2
81 C1 00000001 ;; add ecx, 1             ; point to next byte in addr1
E9 -seql       ;; jmp seql               ; continue loop

:sdnl   ;; string d ends, check string b
81 FB 00000000 ;; cmp ebx, 0             ; check for null terminator
0F 84 -seqo    ;; je seqo                ; if null, goto string equal one
;; otherwise, strings not equal

:seqz   ;; strings not equal
81 EF 00000004 ;; sub edi, 4         ; make space on stack
C7 07 00000000 ;; mov [edi], 0       ; push 0 onto stack
C3             ;; ret

:seqo   ;; strings equal
81 EF 00000004 ;; sub edi, 4         ; make space on stack
C7 07 00000001 ;; mov [edi], 1       ; push 1 onto stack
C3             ;; ret

;; parse-number: ( addr -- number ok ) parse a number from string
;; support decimal and hexadecimal (prefix 0x)
;; return the number and ok 1 if successful, ok 0 if not a number 
00 "parse-number" 00
=steq ;; pointer to previous word
:psnb
8B 07            ;; mov eax, [edi]     ; get addr
81 C7 00000004   ;; add edi, 4         ; pop

;check if hexadecimal
0F B6 18        ;; movzx ebx, byte [eax]  ; get first char

81 FB 00000030  ;; cmp ebx, '0'        ; check first char '0'
0F 85 -pnnh     ;; jne pnnh            ; if not '0', parse-number not hex
0F B6 58 01     ;; movzx ebx, byte [eax+1] ; get second char
81 FB 000000"x" ;; cmp ebx, 'x'        ; check second char 'x'
0F 85 -pnnh     ;; jne pnnh            ; if not 'x', parse-number not hex
;; eax for addr, ebx for base
;; it's hexadecimal
C7 C3 00000010  ;; mov ebx, 16        ; base 16
81 C0 00000002  ;; add eax, 2         ; point to first digit  
E9 -pnLP        ;; jmp pnLP

;; it's decimal
:pnnh   ;; parse-number not hex
C7 C3 0000000A  ;; mov ebx, 10        ; base 10

:pnLP  ;; parse-number loop with initialization
81 EF 00000004  ;; sub edi, 4       ; make space on stack
C7 07 00000000  ;; mov [edi], 0     ; push 0 onto stack for the result

:pnlp   ;; parse-number loop
0F B6 08        ;; movzx ecx, byte [eax]  ; get current char

;; check for end of string
81 F9 00000000  ;; cmp ecx, 0             ; check for null terminator
0F 84 -pnok     ;; je pnok                ; if null, finish parsing

81 EF 00000004  ;; sub edi, 4             ; make space on stack
89 0F           ;; mov [edi], ecx         ; push char onto stack
81 C0 00000001  ;; add eax, 1             ; point to next char

50 53           ;; push eax, ebx, save registers
E8 -psdg        ;; call parse-digit    ; ( char -- digit )
8B 0F           ;; mov ecx, [edi]      ; get current digit
81 F9 FFFFFFFF  ;; cmp ecx, 0xFFFFFFFF ; check if -1
0F 84 -pner     ;; je pner             ; if -1, not a digit

;; got a digit, update the number
5b 58           ;; pop ebx, eax           ; recover registers

;; check if digit is valid (ecx: digit < ebx: base)
39 D9           ;; cmp ecx, ebx           ; compare digit with base
0F 8D -pnER     ;; jge pnER               ; if digit >= base, error

81 C7 00000004  ;; add edi, 4             ; pop

8B 17           ;; mov edx, [edi]         ; get current number
0F AF D3        ;; imul edx, ebx          ; number * base
01 CA           ;; add edx, ecx           ; number + digit
89 17           ;; mov [edi], edx         ; update number
E9 -pnlp        ;; jmp pnlp

:pner   ;; parse-number error
58 58           ;; pop ebx, eax           ; recover stack
:pnER   ;; parse-number error, without cleaning up stack
;; HACK: we don't need edi-=4, because we will overwrite the char on stack
C7 07 00000000  ;; mov [edi], 0           ; push 0 (not ok) onto stack
C3              ;; ret

:pnok   ;; parse-number ok
81 EF 00000004  ;; sub edi, 4             ; make space on stack
C7 07 00000001  ;; mov [edi], 1           ; push 1 (ok) onto stack
C3              ;; ret

;; parse-digit: (char -- digit)  parse a digit, return -1 if not a digit
00 "parse-digit" 00
=psnb ;; pointer to previous word
:psdg
8B 07            ;; mov eax, [edi]      ; get char
81 C7 00000004   ;; add edi, 4          ; pop

81 F8 000000"0"  ;; cmp eax, '0'     ; check if '0' <= ch
0F 8C -pdnd      ;; jl pdnd          ; if ch < '0', not digit
81 F8 000000"9"  ;; cmp eax, '9'     ; check if ch <= '9'
0F 8F -pdnd      ;; jg pdnd          ; if ch > '9', not digit
;; it's a digit
81 E8 000000"0"  ;; sub eax, '0'     ; convert to number
E9 -pret         ;; jmp pret

:pdnd  ;; not a digit, is it a-f or A-F?
81 F8 000000"a"  ;; cmp eax, 'a'     ; check if 'a' <= ch
0F 8C -pnaf      ;; jl pnaf          ; if ch < 'a', not a-f
81 F8 000000"f"  ;; cmp eax, 'f'     ; check if ch <= 'f'
0F 8F -pnaf      ;; jg pnaf          ; if ch > 'f', not a-f
;; it's a-f
81 E8 000000"a"  ;; sub eax, 'a'     ; convert to number
81 C0 0000000A   ;; add eax, 10      ; add 10
E9 -pret         ;; jmp pret

:pnaf  ;; not a digit or a-f, is it A-F?
81 F8 000000"A"  ;; cmp eax, 'A'     ; check if 'A' <= ch
0F 8C -pnaA      ;; jl pnaA          ; if ch < 'A', not A-F
81 F8 000000"F"  ;; cmp eax, 'F'     ; check if ch <= 'F'
0F 8F -pnaA      ;; jg pnaA          ; if ch > 'F', not A-F 
;; it's A-F
81 E8 000000"A"  ;; sub eax, 'A'     ; convert to number
81 C0 0000000A   ;; add eax, 10      ; add 10
E9 -pret         ;; jmp pret

:pret
81 EF 00000004   ;; sub edi, 4       ; make space on stack
89 07            ;; mov [edi], eax   ; push number onto stack
C3               ;; ret

:pnaA  ;; not a digit or a-f or A-F, return -1
81 EF 00000004  ;; sub edi, 4                ; make space on stack
C7 07 FFFFFFFF  ;; mov [edi], 0xFFFFFFFF     ; push -1 onto stack
C3              ;; ret

;; find-word: ( addr -- wordptr immediate ) find a word by its name
;; return wordptr and immediate flag, if not found, return 0 0
00 "find-word" 00
=psdg ;; pointer to previous word
:fdwd
8B 07            ;; mov eax, [edi]      ; get addr (name to find)
81 C7 00000004   ;; add edi, 4          ; pop

8B 0D =HEAD      ;; mov ecx, [HEAD]     ; get latest defined word

81 EF 00000004   ;; sub edi, 4          ; make space on stack
89 0F            ;; mov [edi], ecx      ; push current word ptr onto stack

:fwlp   ;; find-word loop
;; eax: name to find, edx: name of current word
81 F9 00000000   ;; cmp ecx, 0           ; check for null
0F 84 -fwnf      ;; je fwnf              ; if null, not found


81 EF 00000004   ;; sub edi, 4           ; make space on stack
89 0F            ;; mov [edi], ecx       ; push current word ptr onto stack
E8 -fwnm         ;; call word-name 
8B 17            ;; mov edx, [edi]       ; get addr of name of current word

81 EF 00000004   ;; sub edi, 4           ; make space on stack
89 07            ;; mov [edi], eax       ; push addr of name to find

50 52            ;; push eax, edx        ; save registers
E8 -steq         ;; call string==        ; compare the two strings
8B 1F            ;; mov ebx, [edi]       ; get flag
81 C7 00000004   ;; add edi, 4           ; pop

5a 58            ;; pop edx, eax         ; recover registers

81 FB 00000000   ;; cmp ebx, 0           ; check if equal
0F 85 -fwfd      ;; jne fwlp             ; if equal, done

8B 0F            ;; mov ecx, [edi]       ; get current word ptr
8B 49 FC         ;; mov ecx, [ecx-4]     ; get previous word ptr
89 0F            ;; mov [edi], ecx       ; push current word ptr onto stack

E9 -fwlp         ;; jmp fwlp             ; continue loop

:fwfd  ;; found the word
81 EA 00000001   ;; sub edx, 1           ; point to immediate flag
0F B6 0A         ;; movzx ecx, byte [edx]; get a byte of flag
81 EF 00000004   ;; sub edi, 4           ; make space on stack
89 0F            ;; mov [edi], ecx       ; push immediate flag
C3               ;; ret

81 E9 00000004   ;; sub ecx, 4          ; point to previous word field
8B 09            ;; mov ecx, [ecx]      ; get previous word ptr

:fwnf  ;; find-word not found
81 EF 00000004   ;; sub edi, 4          ; make space on stack
C7 07 00000000   ;; mov [edi], 0        ; push 0, not found
C3               ;; ret

;; word-name: ( wordptr -- string ) get the name of a word
00 "word-name" 00
=fdwd ;; pointer to previous word
:fwnm  ;; find the name of current word
8B 17            ;; mov edx, [edi]      ; get word ptr
81 C7 00000004   ;; add edi, 4          ; pop

81 EA 00000006 ;; sub edx, 6           ; point to the last byte of name
:fwnl
0F B6 0A       ;; movzx ecx, byte [edx]  ; get a byte of name
81 F9 00000001 ;; cmp ecx, 1             ; check for null 
0F 86 -fwne    ;; jbe fwne               ; if null, finish name extraction

81 EA 00000001 ;; sub edx, 1             ; point to previous byte
E9 -fwnl       ;; jmp fwnl               ; continue loop

:fwne
81 C2 00000001 ;; add edx, 1             ; point to first byte of name
81 EF 00000004 ;; sub edi, 4             ; make space on stack
89 17          ;; mov [edi], edx         ; push name address onto stack
C3             ;; ret

;; execute: ( wordptr -- ) execute a word by its pointer
00 "execute" 00
=fwnm ;; pointer to previous word
:exec
8B 07           ;; mov eax, [edi]      ; get word ptr
81 C7 00000004  ;; add edi, 4          ; pop
FF D0           ;; call eax            ; call the word
C3              ;; ret

;; string-copy: ( src dest -- len ) copy a string from src to dest
;; return length null terminator included
00 "string-copy" 00
=exec ;; pointer to previous word
:stcp
8B 07            ;; mov eax, [edi]      ; get dest
81 C7 00000004   ;; add edi, 4          ; pop
8B 0F            ;; mov ecx, [edi]      ; get src
81 C7 00000004   ;; add edi, 4          ; pop

C7 C2 00000000   ;; mov edx, 0          ; length counter

:sclp  ;; string copy loop
0F B6 19         ;; movzx ebx, byte [ecx]   ; get byte from src
88 18            ;; mov byte [eax], bl      ; store byte to dest
81 C1 00000001   ;; add ecx, 1              ; point to next byte in src
81 C0 00000001   ;; add eax, 1              ; point to next byte in dest
81 C2 00000001   ;; add edx, 1              ; increment length counter
81 FB 00000000   ;; cmp ebx, 0              ; check for null terminator
0F 85 -sclp      ;; jne sclp                ; if not null, continue loop

81 EF 00000004   ;; sub edi, 4              ; make space on stack
89 17            ;; mov [edi], edx          ; push length onto stack
C3               ;; ret

;; read-eval-print: ( -- ) the REPL loop, return when EOF
00 "repl" 00
=stcp ;; pointer to previous word
:repl
E8 -read         ;; call read
8B 07            ;; mov eax, [edi]      ; get addr
81 F8 00000000   ;; cmp eax, 0          ; check for EOF
0F 84 -repf      ;; je repf             ; if EOF, finish REPL

50               ;; push eax            ; save addr
E8 -psnb         ;; call parse-number  (num ok)
8B 07            ;; mov eax, [edi]      ; get ok
81 C7 00000004   ;; add edi, 4          ; pop

81 F8 00000001   ;; cmp eax, 1          ; check ok
58               ;; pop eax             ; recover stack
0F 84 -repl      ;; je repl             ; if is number, it's done, back to REPL

;; not a number, try to find word
89 07            ;; mov [edi], eax  ; push addr onto stack, cover the garbage
50               ;; push eax        ; save addr
E8 -fdwd         ;; call find-word    (wordptr immediate)

8B 07            ;; mov eax, [edi]      ; get immediate
81 C7 00000004   ;; add edi, 4          ; pop
8B 0F            ;; mov ecx, [edi]      ; get wordptr
81 C7 00000004   ;; add edi, 4          ; pop

81 F9 00000000   ;; cmp ecx, 0          ; check if found
0F 84 -rpnf      ;; je rpnf             ; if not found, goto not found
;; found the word, check if immediate
81 F8 00000001   ;; cmp eax, 1          ; check immediate
0F 85 -rpex      ;; jne rpex            ; if not immediate, execute

;; immediate word, push interface argument
58               ;; pop eax             ; recover stack
81 EF 00000004   ;; sub edi, 4          ; make space on stack
C7 07 00000000   ;; mov [edi], 0        ; push 0 onto stack
81 EF 00000004   ;; sub edi, 4          ; make space on stack
89 0F            ;; mov [edi], ecx      ; push addr onto stack
;; (0 addr ) then exec the immediate word
E8 -exec         ;; call execute
81 C7 00000004   ;; add edi, 4          ; discard the return value
E9 -repl         ;; jmp repl            ; back to REPL

:rpex ;; execute the word
58               ;; pop eax             ; recover stack
81 EF 00000004   ;; sub edi, 4          ; make space on stack
89 0F            ;; mov [edi], ecx      ; push addr onto stack
E8 -exec         ;; call execute
E9 -repl         ;; jmp repl            ; back to REPL

:rpnf ;; word not found, print `word?` and continue
58               ;; pop eax             ; recover addr
81 EF 00000004   ;; sub edi, 4          ; make space on stack
89 07            ;; mov [edi], eax      ; push addr onto stack
E8 -ptst         ;; call put-string     ; print the string

81 EF 00000004   ;; sub edi, 4          ; make space on stack
C7 07 000000"?"  ;; mov [edi], "?"      ; push "?" onto stack
E8 -ptch         ;; call put-char       ; print '?'
E9 -repl         ;; jmp repl            ; back to REPL

:repf ;; finish REPL
81 C7 00000004   ;; add edi, 4          ; pop
C3               ;; ret

;; emit-byte: ( byte -- ) emit a byte to free text space
00 "emit-byte" 00
=repl ; pointer to previous word
:embt
C7 C0 =FTXT    ;; mov eax, FTXT         ; get free text pointer
8B 08          ;; mov ecx, [eax]        ; get current free text pointer
8B 17          ;; mov edx, [edi]        ; get byte to emit
88 11          ;; mov byte [ecx], dl    ; store the byte
81 C1 00000001 ;; add ecx, 1            ; increment free text pointer
89 08          ;; mov [eax], ecx        ; update FTXT
81 C7 00000004 ;; add edi, 4            ; pop
C3             ;; ret

;; emit-word: ( word -- ) emit a 4-byte word to free text space
00 "emit-word" 00
=embt ; pointer to previous word
:emwd
C7 C0 =FTXT    ;; mov eax, FTXT         ; get free text pointer
8B 08          ;; mov ecx, [eax]        ; get current free text pointer
8B 17          ;; mov edx, [edi]        ; get word to emit
89 11          ;; mov [ecx], edx        ; store the word
81 C1 00000004 ;; add ecx, 4            ; increment free text pointer
89 08          ;; mov [eax], ecx        ; update FTXT
81 C7 00000004 ;; add edi, 4            ; pop
C3             ;; ret

;; emit-offset: ( offset -- ) emit a 4-byte offset to free text space
00 "emit-offset" 00
=emwd ; pointer to previous word
:emof
C7 C0 =FTXT    ;; mov eax, FTXT         ; get free text pointer
8B 08          ;; mov ecx, [eax]        ; get current free text pointer
8B 17          ;; mov edx, [edi]        ; get offset to emit
29 CA          ;; sub edx, ecx          ; convert to offset
81 EA 00000004 ;; sub edx, 4            ; adjust for next instruction
89 11          ;; mov [ecx], edx        ; store the offset
81 C1 00000004 ;; add ecx, 4            ; increment free text pointer
89 08          ;; mov [eax], ecx        ; update FTXT
81 C7 00000004 ;; add edi, 4            ; pop
C3             ;; ret

;; : : ( -- ) start a new word definition
00 ":" 00
=emof ;; pointer to previous word
:coln
;; save FTXT and HEAD for recovering if needed
8B 05 =FTXT        ;; mov eax, [FTXT]       ; get free text pointer
50                 ;; push eax              ; save free text pointer
8B 05 =HEAD        ;; mov eax, [HEAD]       ; get head pointer
50                 ;; push eax              ; save head pointer

;; create new word header
81 EF 00000004         ;; sub edi, 4         ; make space on stack
C7 07 00000000         ;; mov [edi], 0       ; push 0
E8 -embt               ;; call emit-byte     ; emit 00

E8 -read               ;; call read          ; get word name
8B 07                  ;; mov eax, [edi]     ; get addr
81 F8 00000000         ;; cmp eax, 0         ; check for EOF
0F 84 -cerr            ;; je cerr            ; if EOF, compile error

E8 -emst               ;; call emit-string   ; emit the word name

8B 05 =HEAD            ;; mov eax, [HEAD]    ; get previous HEAD
81 EF 00000004         ;; sub edi, 4         ; make space on stack
89 07                  ;; mov [edi], eax     ; push previous HEAD
E8 -emwd               ;; call emit-word     ; emit previous word ptr
;; update HEAD
8B 05 =FTXT            ;; mov eax, [FTXT]    ; get free text pointer
89 05 =HEAD            ;; mov [HEAD], eax    ; update HEAD

;; start compiling
:ccml  ;; compile loop
E8 -read               ;; call read          ; read first token
8B 07                  ;; mov eax, [edi]     ; get addr
81 C7 00000004         ;; add edi, 4         ; pop

81 F8 00000000         ;; cmp eax, 0         ; check for EOF
0F 84 -cerr            ;; je cerr            ; if EOF, compile error

;; HACK: the addr is on stack
81 EF 00000004         ;; sub edi, 4         ; make space on stack
50                     ;; push eax           ; save addr
E8 -psnb               ;; call parse-number  (num ok)
8B 07                  ;; mov eax, [edi]     ; get ok
81 C7 00000004         ;; add edi, 4         ; pop

81 F8 00000001         ;; cmp eax, 1         ; check ok
58                     ;; pop eax            ; recover stack
0F 84 -cnum            ;; je cnum            ; if is number, compile number

;; not a number, try to find word
89 07                  ;; mov [edi], eax     ; push addr onto stack, cover the garbage
50                     ;; push eax           ; save addr
E8 -fdwd               ;; call find-word    (wordptr immediate)

8B 07                  ;; mov eax, [edi]     ; get immediate
81 C7 00000004         ;; add edi, 4         ; pop
8B 0F                  ;; mov ecx, [edi]     ; get wordptr
81 C7 00000004         ;; add edi, 4         ; pop

81 F9 00000000         ;; cmp ecx, 0         ; check if found
0F 84 -cerR            ;; je cerR            ; if not found, compile error
;; found the word, check if immediate
81 F8 00000001         ;; cmp eax, 1         ; check immediate
0F 85 -cwrd            ;; jne cwrd           ; if not immediate, compile

;; immediate word, push interface argument
58                     ;; pop eax            ; recover stack
81 EF 00000004         ;; sub edi, 4         ; make space on stack
C7 07 00000001         ;; mov [edi], 1       ; push 1 onto stack
81 EF 00000004         ;; sub edi, 4         ; make space on stack
89 0F                  ;; mov [edi], ecx     ; push wordptr onto stack
E8 -exec               ;; call execute       ; execute the immediate word

81 3F 00000003         ;; cmp [edi], 3       ; check if we need to stop compiling
0F 85 -ccnt            ;; jne ccnt           ; if not, continue compile loop

;; stop compiling, but leave the word in memory
81 C7 00000004         ;; add edi, 4         ; pop
58 58                  ;; pop pop            ; recover stack
C3                     ;; ret

:ccnt
81 C7 00000004         ;; add edi, 4         ; pop, discard the return value
E9 -ccml               ;; jmp ccml           ; continue compile loop

:cwrd ;; compile word
;; emit: E8 <offset> of wordptr
58                     ;; pop eax            ; recover stack
51                     ;; push ecx           ; save wordptr

81 EF 00000004        ;; sub edi, 4         ; make space on stack
C7 07 000000E8        ;; mov [edi], E8 
E8 -embt              ;; call emit-byte     ; emit byte

59                     ;; pop ecx            ; recover wordptr
81 EF 00000004         ;; sub edi, 4         ; make space on stack
89 0F                  ;; mov [edi], ecx     ; push wordptr onto stack
E8 -emof               ;; call emit-offset   ; emit offset
E9 -ccml               ;; jmp ccml           ; continue compile loop

:cnum ;; compile number
;; emit: 81 EF 00000004 C7 07 <number>

81 EF 00000004      ;; sub edi, 4         ; make space on stack
C7 07 81 EF 04 00   ;; mov [edi], 81 EF 04 00
E8 -emwd            ;; call emit-word     ; emit word

81 EF 00000004      ;; sub edi, 4         ; make space on stack
C7 07 00 00 C7 07   ;; mov [edi], C7 07 00 00
E8 -emwd            ;; call emit-word     ; emit word

E8 -emwd            ;; call emit-word     ; emit the number
E9 -ccml            ;; jmp ccml           ; continue compile loop


:cerR ;; compile error, for word not found
58                     ;; pop eax             ; recover addr
81 EF 00000004         ;; sub edi, 4          ; make space on stack
89 07                  ;; mov [edi], eax      ; push addr onto stack
E8 -ptst               ;; call put-string     ; print the string

81 EF 00000004         ;; sub edi, 4          ; make space on stack
C7 07 000000"?"        ;; mov [edi], "?"      ; push "?" onto stack
E8 -ptch               ;; call put-char       ; print '?'

:cerr ;; compile error, recover FTXT and HEAD
58                     ;; pop eax             ; recover head pointer
89 05 =HEAD            ;; mov [HEAD], eax     ; restore HEAD
58                     ;; pop eax             ; recover free text pointer
89 05 =FTXT            ;; mov [FTXT], eax     ; restore FTXT
C3                     ;; ret

;; ; : ( -- ) end a word definition
01 ";" 00
=coln ;; pointer to previous word
:scln
81 3F 00000000         ;; cmp [edi], 0       ; check if in compiling mode
0F 85 -scmp            ;; jne scmp           ; jmp to compile
C3                     ;; ret                ; not compiling, just return

:scmp  ;; is compiling, finish the word definition
;; emit: C3
C7 07 000000C3         ;; mov [edi], C3       ; push C3 onto stack
E8 -embt               ;; call emit-byte      ; emit byte

81 EF 00000004         ;; sub edi, 4          ; make space on stack
C7 07 00000003         ;; mov [edi], 3        ; push 3 onto stack to stop compiling
C3                     ;; ret

;; immediate : ( -- ) make the current word immediate
00 "immediate" 00
=scln ;; pointer to previous word
:immd
8B 05 =HEAD            ;; mov eax, [HEAD]     ; get current HEAD
81 EF 00000004         ;; sub edi, 4          ; make space on stack
89 07                  ;; mov [edi], eax      ; push current HEAD
E8 -fwnm               ;; call word-name      ; get name of current word
8B 07                  ;; mov eax, [edi]      ; get addr
81 C7 00000004         ;; add edi, 4          ; pop
C6 40 FF 01            ;; mov byte [eax-1], 1 ; set immediate flag
C3                     ;; ret

;; emit-string: ( addr -- ) emit a null-terminated string to free text space
00 "emit-string" 00
=immd ;; pointer to previous word
:emst
:LAST
8B 05 =FTXT        ;; mov eax, [FTXT]       ; get free text pointer
81 EF 00000004     ;; sub edi, 4           ; make space on stack
89 07              ;; mov [edi], eax       ; push free text pointer
E8 -stcp           ;; call string-copy     ; copy the string
8B 07              ;; mov eax, [edi]       ; get length
81 C7 00000004     ;; add edi, 4           ; pop
01 05 =FTXT        ;; add [FTXT], eax      ; advance free text pointer
C3                 ;; ret

:EOF ; need one whitespace after last label

