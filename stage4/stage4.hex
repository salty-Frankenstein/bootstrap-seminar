;; Implement a basic Forth interpreter using stage3

;; Set up labels for variables and segments:
00200000@ :glbl  ; global variables
00200004@ :fdin  ; file descriptor for input
00200008@ :fdot  ; file descriptor for output

00200020@ :temp  ; temporary variable for internal use
00300000@ :fstk  ; forth stack

;; text segment starts at virtual address 00010000
00010000@ :text

;; ELF header:
7F "ELF" 01 01 01 00
00 00 00 00 00 00 00 00

0002     ; type
0003     ; machine
00000000 ; version
=main    ; entry
$PH      ; phoff (00000034)
00000000 ; shoff
00000000 ; flags
0034     ; ehsize
0020     ; phentsize
0003     ; phnum (3)
0000     ; shentsize
0000     ; shnum
0000     ; shstrndx

:PH
;; Program header 1: the program text.
;; It also contains the words to be loaded later.
00000001 ; type
00000000 ; offset
=text    ; vaddr
00000000 ; paddr
$EOF     ; filesz
00100000 ; memsz 1 MiB
00000007 ; flags
00001000 ; alignment

;; Program header 2: global variables, 4 KiB
00000001 ; type
00000000 ; offset
=glbl    ; vaddr
00000000 ; paddr
00000000 ; filesz
00001000 ; memsz 4 KiB
00000006 ; flags (no execute)
00001000 ; alignment

;; Program header 3: forth stack, 1 MiB
;; from 0x00300000 to 0x00400000
;; the stack pointer is edi, pointed to 0x00400000 initialialy
00000001 ; type
00000000 ; offset
=fstk    ; vaddr
00000000 ; paddr
00000000 ; filesz
00100000 ; memsz 1 MiB
00000006 ; flags (no execute)
00001000 ; alignment

;; put a test string here
:tstr
"hello, World!" 00

:main   ;; entry point, it starts the repl

;; initialize the Forth stack pointer
C7 C7 00400000        ;; mov edi, 0x00400000  ; point to the top of the forth stack
;; initialize file descriptors
C7 05 =fdin 00000000  ;; mov [fdin], 0      ; store in fdin
C7 05 =fdot 00000001  ;; mov [fdot], 1      ; store in fdot

;; before we reach a repl, we may test some words here

;; test string output
81 EF 00000004  ;; sub edi, 4            ; make space on stack
C7 C0 =tstr     ;; mov eax, =tstr   ; push a string address
89 07           ;; mov [edi], eax  
E8 -ptst     ;; call put-string   ( addr )

;; test ! and @, !b and @b, put-char and get-char
81 EF 00000004  ;; sub edi, 4      ; make space on stack
C7 C0 =glbl     ;; mov eax, =glbl  ; push address of a global variable
89 07           ;; mov [edi], eax  

E8 -dup      ;; call dup    (addr addr)

81 EF 00000004  ;; sub edi, 4            ; make space on stack
C7 C0 c0ffeeab  ;; mov eax, 0xc0ffeeab   ; push a 0xc0ffeeab 
89 07           ;; mov [edi], eax  (addr addr 0xc0ffeeab) 
E8 -wtad     ;; call !                   ; glbl <- 0xc0ffeeab ( addr )

E8 -dup      ;; call dup    (addr addr)
E8 -gtch     ;; call get-char  (addr addr char)        
E8 -dup      ;; call dup    (addr addr char char)
E8 -ptch     ;; call put-char  (addr addr char)

E8 -wtab     ;; call !b               ; glbl[0] <- char ( addr )
;; glbl = 0xc0ffeeab -> 0xc0ffee42

E8 -dup      ;; call dup    (addr addr)
E8 -rdab     ;; call @b               ; push glbl[0] ( addr char )
E8 -swap     ;; call swap             ; ( char addr )

E8 -rdad     ;; call @         ; ( char 0xc0ffeeab )

;; E8 -repl  ;; call repl

;; call exit
C7 C0 00000001  ;; mov eax, 1       ; syscall: exit
C7 C3 00000000  ;; mov ebx, 0       ; status: 0
CD 80           ;; int 0x80         ; make syscall

;; following is the built-in Forth words
;; 1 byte for type: normal (0) or immediate (1)
;; name of the word, 0 terminated
;; 4 bytes for a pointer to the previous word (at the first byte of code)
;; the code of the word

;; dup: ( n -- n n )
00 "dup" 00
00000000 ;; pointer to previous word
:dup
8B 07           ;; mov eax, [edi]  ; get the top of stack
81 EF 00000004  ;; sub edi, 4      ; make space on stack
89 07           ;; mov [edi], eax  ; push eax onto stack
C3              ;; ret

;; drop: ( n -- )
00 "drop" 00
=dup ;; pointer to previous word
:drop
81 C7 00000004  ;; add edi, 4      ; just move the stack pointer up
C3              ;; ret

;; swap: ( n1 n2 -- n2 n1 )
00 "swap" 00
=drop ;; pointer to previous word
:swap
8B 07           ;; mov eax, [edi]      ; get n2
8B 4F 04        ;; mov ecx, [edi+4]    ; get n1
89 47 04        ;; mov [edi+4], ecx    ; put n1 to n2 position
89 0F           ;; mov [edi], eax      ; put n2 to n1 position
C3              ;; ret

;; @: ( addr -- value ) read address
00 "@" 00
=swap ;; pointer to previous word
:rdad
8B 07           ;; mov eax, [edi]      ; get addr
8B 00           ;; mov eax, [eax]      ; get value at addr
89 07           ;; mov [edi], eax     ; push value onto stack
C3              ;; ret

;; !: ( addr value -- ) write address
00 "!" 00
=rdad ;; pointer to previous word
:wtad
8B 07           ;; mov eax, [edi]      ; get value
81 C7 00000004  ;; add edi, 4          ; pop
8B 0F           ;; mov ecx, [edi]      ; get addr
89 01           ;; mov [ecx], eax      ; store value at addr
81 C7 00000004  ;; add edi, 4          ; adjust stack pointer
C3              ;; ret

;; @b: ( addr -- byte ) read byte
00 "@b" 00
=wtad ;; pointer to previous word
:rdab
8B 07           ;; mov eax, [edi]        ; get addr
0F B6 00        ;; movzx eax, byte [eax] ; get byte at addr
89 07           ;; mov [edi], eax        ; push byte onto stack
C3              ;; ret

;; !b: ( addr byte -- ) write byte
00 "!b" 00
=rdab ;; pointer to previous word
:wtab
8B 07           ;; mov eax, [edi]      ; get byte
81 C7 00000004  ;; add edi, 4          ; pop
8B 0F           ;; mov ecx, [edi]      ; get addr
88 01           ;; mov byte [ecx], al  ; store byte at addr
81 C7 00000004  ;; add edi, 4          ; adjust stack pointer
C3              ;; ret

;; get-char: ( -- char ) read a char from fdin
00 "get-char" 00
=wtab ;; pointer to previous word
:gtch

C7 C0 00000003          ;; mov eax, 3
8B 1D =fdin             ;; mov ebx, [fdin]      ; file descriptor
C7 C1 =temp             ;; mov ecx, temp
C7 C2 00000001          ;; mov edx, 1
CD 80                   ;; int 0x80

;; if read EOF, return -1
81 F8 00000000          ;; cmp eax, 0
0F 84 -reof             ;; je reof
8B 05 =temp             ;; mov eax, [temp]
81 EF 00000004          ;; sub edi, 4        ; make space on stack
89 07                   ;; mov [edi], eax    ; push eax onto stack
C3                      ;; ret
:reof
C7 C0 FFFFFFFF          ;; mov eax, 0xFFFFFFFF  ; return -1
81 EF 00000004          ;; sub edi, 4        ; make space on stack
89 07                   ;; mov [edi], eax    ; push eax onto stack
C3                      ;; ret

;; put-char: ( char -- ) write a char to fdot
00 "put-char" 00
=gtch ;; pointer to previous word
:ptch
8B 07                   ;; mov eax, [edi]       ; get the char to write
81 C7 00000004          ;; add edi, 4           ; pop
C7 C0 00000004          ;; mov eax, 4           ; syscall: write
8B 1D =fdot             ;; mov ebx, [fdot]      ; file descriptor
89 F9                   ;; mov ecx, edi         ; buffer to write
C7 C2 00000001          ;; mov edx, 1           ; write 1 byte
CD 80                   ;; int 0x80             ; make syscall
C3                      ;; ret

;; put-string: ( addr -- ) write a string to fdot
00 "put-string" 00
=ptch ;; pointer to previous word
:ptst
8B 0F                   ;; mov ecx, [edi]       ; get the addr of string
81 C7 00000004          ;; add edi, 4           ; pop
;; count length in edx
C7 C2 FFFFFFFF          ;; mov edx, 0xFFFFFFFF  ; edx = -1
:lcnt
81 C2 00000001          ;; add edx, 1           ; edx++
0F B6 18                ;; movzx ebx, [eax]     ; get a byte
81 C0 00000001          ;; add eax, 1           ; point to next byte
81 FB 00000000          ;; cmp ebx, 0           ; check for null terminator
0F 85 -lcnt             ;; jne lcnt             ; if not null, continue
;; write the string
C7 C0 00000004          ;; mov eax, 4           ; syscall: write
8B 1D =fdot             ;; mov ebx, [fdot]      ; file descriptor
;; ecx already has the buffer address
;; edx already has the length
CD 80                   ;; int 0x80             ; make syscall
C3                      ;; ret

:EOF ; need one whitespace after last label

