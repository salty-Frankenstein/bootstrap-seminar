;; Implement a basic Forth interpreter using stage3

;; Set up labels for variables and segments:
00200000@ :glbl  ; global variables
00200004@ :FDIN  ; file descriptor for input
00200008@ :FDOT  ; file descriptor for output
0020000C@ :FTXT  ; pointer to free text space
00200010@ :FSTR  ; pointer to free string space
00200014@ :HEAD  ; pointer to the latest defined word
00200018@ :OESP  ; original esp 


00200020@ :temp  ; temporary variable for internal use
00300000@ :fstk  ; forth stack
00100000@ :fstz  ; forth stack size
00500000@ :strb  ; string buffer

;; text segment starts at virtual address 00010000
00010000@ :text

;; ELF header:
7F "ELF" 01 01 01 00
00 00 00 00 00 00 00 00

0002     ; type
0003     ; machine
00000000 ; version
=main    ; entry
$PH      ; phoff (00000034)
00000000 ; shoff
00000000 ; flags
0034     ; ehsize
0020     ; phentsize
0004     ; phnum (4)
0000     ; shentsize
0000     ; shnum
0000     ; shstrndx

:PH
;; Program header 1: the program text.
;; It also contains the words to be loaded later.
00000001 ; type
00000000 ; offset
=text    ; vaddr
00000000 ; paddr
$EOF     ; filesz
00100000 ; memsz 1 MiB
00000007 ; flags
00001000 ; alignment

;; Program header 2: global variables, 4 KiB
00000001 ; type
00000000 ; offset
=glbl    ; vaddr
00000000 ; paddr
00000000 ; filesz
00001000 ; memsz 4 KiB
00000006 ; flags (no execute)
00001000 ; alignment

;; Program header 3: forth stack, 1 MiB
;; from 0x00300000 to 0x00400000
;; the stack pointer is edi, pointed to 0x00400000 initialialy
00000001 ; type
00000000 ; offset
=fstk    ; vaddr
00000000 ; paddr
00000000 ; filesz
00100000 ; memsz 1 MiB
00000006 ; flags (no execute)
00001000 ; alignment

;; Program header 4: string buffer, 1 MiB
;; from 0x00500000 to 0x00600000
00000001 ; type
00000000 ; offset
=strb    ; vaddr
00000000 ; paddr
00000000 ; filesz
00100000 ; memsz 1 MiB
00000006 ; flags (no execute)
00001000 ; alignment

;; put a test string here
:tstr
"hello, World!" 00

:main   ;; entry point, it starts the repl

;; initialize the Forth stack pointer
C7 C7 00400000        ;; mov edi, 0x00400000  ; point to the top of the forth stack
;; initialize file descriptors
C7 05 =FDIN 00000000  ;; mov [FDIN], 0      ; store in FDIN
C7 05 =FDOT 00000001  ;; mov [FDOT], 1      ; store in FDOT
;; initialize free text and string space pointers
C7 C0 =EOF            ;; mov eax, =EOF      ; pointer to the end of code segment
89 05 =FTXT           ;; mov [FTXT], eax    ; store in FTXT
C7 05 =FSTR 00500000  ;; mov [FSTR], 0x00500000 ; store in FSTR
89 25 =OESP           ;; mov [OESP], edi    ; store original esp
C7 C0 =LAST           ;; mov eax, =LAST     ; pointer to the end of the word definitions
89 05 =HEAD           ;; mov [HEAD], eax    ; store in HEAD
C7 C0 =EOF            ;; mov eax, =EOF      ; pointer to the end of code segment
89 05 =FTXT           ;; mov [FTXT], eax    ; store in FTXT     

;; before we reach a repl, we may test some words here
E8 -read     ;; call read@
E8 -read     ;; call read@
E8 -ptst     ;; call put-string@

;; E8 -repl  ;; call repl

;; call exit
C7 C0 00000001  ;; mov eax, 1       ; syscall: exit
C7 C3 00000000  ;; mov ebx, 0       ; status: 0
CD 80           ;; int 0x80         ; make syscall

;; following is the built-in Forth words
;; 1 byte for type: normal (0) or immediate (1)
;; name of the word, 0 terminated
;; 4 bytes for a pointer to the previous word (at the first byte of code)
;; the code of the word

;; dup: ( n -- n n )
00 "dup" 00
00000000 ;; pointer to previous word
:dup
8B 07           ;; mov eax, [edi]  ; get the top of stack
81 EF 00000004  ;; sub edi, 4      ; make space on stack
89 07           ;; mov [edi], eax  ; push eax onto stack
C3              ;; ret

;; drop: ( n -- )
00 "drop" 00
=dup ;; pointer to previous word
:drop
81 C7 00000004  ;; add edi, 4      ; just move the stack pointer up
C3              ;; ret

;; swap: ( n1 n2 -- n2 n1 )
00 "swap" 00
=drop ;; pointer to previous word
:swap
8B 07           ;; mov eax, [edi]      ; get n2
8B 4F 04        ;; mov ecx, [edi+4]    ; get n1
89 47 04        ;; mov [edi+4], ecx    ; put n1 to n2 position
89 0F           ;; mov [edi], eax      ; put n2 to n1 position
C3              ;; ret

;; @: ( addr -- value ) read address
00 "@" 00
=swap ;; pointer to previous word
:rdad
8B 07           ;; mov eax, [edi]      ; get addr
8B 00           ;; mov eax, [eax]      ; get value at addr
89 07           ;; mov [edi], eax     ; push value onto stack
C3              ;; ret

;; !: ( addr value -- ) write address
00 "!" 00
=rdad ;; pointer to previous word
:wtad
8B 07           ;; mov eax, [edi]      ; get value
81 C7 00000004  ;; add edi, 4          ; pop
8B 0F           ;; mov ecx, [edi]      ; get addr
89 01           ;; mov [ecx], eax      ; store value at addr
81 C7 00000004  ;; add edi, 4          ; adjust stack pointer
C3              ;; ret

;; @b: ( addr -- byte ) read byte
00 "@b" 00
=wtad ;; pointer to previous word
:rdab
8B 07           ;; mov eax, [edi]        ; get addr
0F B6 00        ;; movzx eax, byte [eax] ; get byte at addr
89 07           ;; mov [edi], eax        ; push byte onto stack
C3              ;; ret

;; !b: ( addr byte -- ) write byte
00 "!b" 00
=rdab ;; pointer to previous word
:wtab
8B 07           ;; mov eax, [edi]      ; get byte
81 C7 00000004  ;; add edi, 4          ; pop
8B 0F           ;; mov ecx, [edi]      ; get addr
88 01           ;; mov byte [ecx], al  ; store byte at addr
81 C7 00000004  ;; add edi, 4          ; adjust stack pointer
C3              ;; ret

;; get-char: ( -- char ) read a char from FDIN
00 "get-char" 00
=wtab ;; pointer to previous word
:gtch

C7 C0 00000003          ;; mov eax, 3
8B 1D =FDIN             ;; mov ebx, [FDIN]      ; file descriptor
C7 C1 =temp             ;; mov ecx, temp
C7 C2 00000001          ;; mov edx, 1
CD 80                   ;; int 0x80

;; if read EOF, return -1
81 F8 00000000          ;; cmp eax, 0
0F 84 -reof             ;; je reof
8B 05 =temp             ;; mov eax, [temp]
81 EF 00000004          ;; sub edi, 4        ; make space on stack
89 07                   ;; mov [edi], eax    ; push eax onto stack
C3                      ;; ret
:reof
C7 C0 FFFFFFFF          ;; mov eax, 0xFFFFFFFF  ; return -1
81 EF 00000004          ;; sub edi, 4        ; make space on stack
89 07                   ;; mov [edi], eax    ; push eax onto stack
C3                      ;; ret

;; put-char: ( char -- ) write a char to FDOT
00 "put-char" 00
=gtch ;; pointer to previous word
:ptch
8B 07                   ;; mov eax, [edi]       ; get the char to write
81 C7 00000004          ;; add edi, 4           ; pop
C7 C0 00000004          ;; mov eax, 4           ; syscall: write
8B 1D =FDOT             ;; mov ebx, [FDOT]      ; file descriptor
89 F9                   ;; mov ecx, edi         ; buffer to write
C7 C2 00000001          ;; mov edx, 1           ; write 1 byte
CD 80                   ;; int 0x80             ; make syscall
C3                      ;; ret

;; put-string: ( addr -- ) write a string to FDOT
00 "put-string" 00
=ptch ;; pointer to previous word
:ptst
8B 0F                   ;; mov ecx, [edi]       ; get the addr of string
81 C7 00000004          ;; add edi, 4           ; pop
;; count length in edx
C7 C2 FFFFFFFF          ;; mov edx, 0xFFFFFFFF  ; edx = -1
:lcnt
81 C2 00000001          ;; add edx, 1           ; edx++
0F B6 18                ;; movzx ebx, [eax]     ; get a byte
81 C0 00000001          ;; add eax, 1           ; point to next byte
81 FB 00000000          ;; cmp ebx, 0           ; check for null terminator
0F 85 -lcnt             ;; jne lcnt             ; if not null, continue
;; write the string
C7 C0 00000004          ;; mov eax, 4           ; syscall: write
8B 1D =FDOT             ;; mov ebx, [FDOT]      ; file descriptor
;; ecx already has the buffer address
;; edx already has the length
CD 80                   ;; int 0x80             ; make syscall
C3                      ;; ret

;; head@: ( -- addr ) get the latest defined word address
00 "head@" 00
=ptst ;; pointer to previous word
:hdat
81 EF 00000004         ;; sub edi, 4           ; make space on stack
C7 07 =HEAD            ;; mov [edi], HEAD      ; get HEAD
C3                     ;; ret

;; free@: ( -- addr ) get the free text space pointer
00 "free@" 00
=hdat ;; pointer to previous word
:ftat
81 EF 00000004         ;; sub edi, 4           ; make space on stack
C7 07 =FTXT            ;; mov [edi], FTXT      ; get FTXT
C3                     ;; ret

;; old-esp@: ( -- addr ) get the original esp
00 "old-esp@" 00
=ftat ;; pointer to previous word
:oesp
81 EF 00000004        ;; sub edi, 4           ; make space on stack
C7 07 =OESP           ;; mov [edi], OESP      ; push OESP onto stack
C3                    ;; ret

;; fd-in@: ( -- fd ) get FDIN
00 "fd-in@" 00
=oesp ;; pointer to previous word
:fdin
81 EF 00000004        ;; sub edi, 4           ; make space on stack
C7 07 =FDIN           ;; mov [edi], FDIN      ; push FDIN onto stack
C3                    ;; ret

;; fd-out@: ( -- fd ) get FDOT
00 "fd-out@" 00
=fdin ;; pointer to previous word
:fdot
81 EF 00000004        ;; sub edi, 4           ; make space on stack
C7 07 =FDOT           ;; mov [edi], FDOT      ; push FDOT onto stack
C3                    ;; ret

;; stack-min@: ( -- addr ) get the minimum address of the forth stack
00 "stack-min@" 00
=fdot ;; pointer to previous word
:smin
81 EF 00000004       ;; sub edi, 4           ; make space on stack
C7 07 =fstk          ;; mov [edi], fstk      ; push onto stack
C3                   ;; ret

;; stack-size: ( -- size ) get the size of the forth stack
00 "stack-size" 00
=smin ;; pointer to previous word
:stsz
81 EF 00000004       ;; sub edi, 4           ; make space on stack
C7 07 =fstz          ;; mov [edi], fstz      ; push onto stack
C3                   ;; ret

;; stack-curr@: ( -- addr ) get the current top address of the forth stack
00 "stack-curr@" 00
=stsz ;; pointer to previous word
:stcr 
89 F8                ;; mov eax, edi         ; get current top of forth stack
81 EF 00000004       ;; sub edi, 4           ; make space on stack
89 07                ;; mov [edi], eax       ; push onto stack
C3                   ;; ret

;; read: ( -- string ) read a line from FDIN into string buffer
;; if EOF, return 0
;; skip leading whitespaces 
;; terminate at first whitespace
00 "read" 00
=stcr ;; pointer to previous word
:read
:LAST
;; save the starting address of string buffer
8B 05 =FSTR       ;; mov eax, [FSTR]
50                ;; push eax
;; read characters into string buffer
:rlpA   ;; read loop A: skip leading whitespaces
E8 -gtch         ;; call get-char       ; ( addr char )
8B 07            ;; mov eax, [edi]      ; get char
81 C7 00000004   ;; add edi, 4          ; remember to pop
81 F8 FFFFFFFF   ;; cmp eax, -1         ; check for EOF
0F 84 -Reof      ;; je Reof             ; if EOF, finish

:rdsp
81 F8 00000020   ;; cmp eax, 0x20       ; check for whitespace
0F 86 -rlpA      ;; jbe rlpA             ; if whitespace, goto loop

;; store the character into string buffer
:rlpB    ;; read loop B: store characters
8B 0D =FSTR          ;; mov ecx, [FSTR]     ; get string buffer pointer
88 01                ;; mov byte [ecx], al  ; store the character
81 05 =FSTR 00000001 ;; add dword [FSTR], 1 ; increment string buffer pointer
E8 -gtch             ;; call get-char       ; ( addr char )
8B 07                ;; mov eax, [edi]      ; get char
81 C7 00000004       ;; add edi, 4          ; pop
81 F8 00000020       ;; cmp eax, 0x20       ; check for whitespace (also EOF)
0F 87 -rlpB          ;; ja rlpB             ; if not whitespace, continue loop

;; terminate the string
8B 0D =FSTR          ;; mov ecx, [FSTR]     ; get string buffer pointer
C6 01 00             ;; mov byte [ecx], 0   ; null terminate
81 05 =FSTR 00000001 ;; add dword [FSTR], 1 ; point to next free space
;; pop the starting address of string buffer
58                   ;; pop eax
;; push the address onto stack
81 EF 00000004       ;; sub edi, 4           ; make space on stack
89 07                ;; mov [edi], eax       ; push address onto stack
C3                   ;; ret

:Reof   ;; carefully avoid label conflict
81 EF 00000004       ;; sub edi, 4           ; make space on stack
C7 07 00000000       ;; mov [edi], 0
58                   ;; pop eax         ; clean up stack
C3                   ;; ret


:EOF ; need one whitespace after last label

